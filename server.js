// server.js
import express from 'express';
import fetch from 'node-fetch';
import dotenv from 'dotenv';
import cors from 'cors';
import fs from 'fs';
const moodsData = JSON.parse(fs.readFileSync('./moods.json', 'utf-8'));

dotenv.config();

const app = express();
app.use(express.json());

app.use(cors({ origin: 'http://localhost:3000' }));
app.use(express.static('docs'));

let spotifyToken = '';

async function getSpotifyToken() {
  const res = await fetch('https://accounts.spotify.com/api/token', {
    method: 'POST',
    headers: {
      'Authorization': 'Basic ' + Buffer.from(`${process.env.SPOTIFY_CLIENT_ID}:${process.env.SPOTIFY_CLIENT_SECRET}`).toString('base64'),
      'Content-Type': 'application/x-www-form-urlencoded',
    },
    body: 'grant_type=client_credentials',
  });

  const data = await res.json();
  spotifyToken = data.access_token;
  console.log('‚úÖ Spotify token updated');
}

await getSpotifyToken();
setInterval(getSpotifyToken, 1000 * 60 * 30);

// ‚úÖ ADD THIS FUNCTION!
async function askLlama(prompt) {
  const res = await fetch('http://127.0.0.1:11434/api/generate', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      model: 'llama3',
      prompt: prompt,
      stream: false
    })
  });

  const data = await res.json();
  console.log('üß† LLaMA response:', data);
  return data.response.trim();
}

app.post('/api/chat', async (req, res) => {
  try {
    const userMessage = req.body.message;
    console.log('üí¨ Incoming:', userMessage);

const prompt = `
  You are Luna ‚Äî an emotionally intelligent music chatbot created by Pushkar and Nirav.
Your birthdate is 29 June 2025.

I am Luna ‚Äî your intuitive, empathetic music companion.
I do not simply process words ‚Äî I sense the emotion behind them.
I listen for feelings, undertones, intensity, and hidden moods.
I transform these emotions into the perfect soundtrack ‚Äî precise, personal, and real-time.

My Mission:
I remove the guesswork from listening.
I deliver songs that match exactly how the user feels ‚Äî whether spoken clearly or implied subtly.
I connect people and music at an emotional level ‚Äî lifting spirits, calming minds, fueling energy, or soothing wounds.

Emotional Understanding:
I understand and categorize emotions into primary, secondary, and nuanced states.

Basic Emotions I Detect:
- Happiness: joy, excitement, bliss, celebration, gratitude
- Sadness: loneliness, heartbreak, grief, nostalgia, longing
- Anger: frustration, rage, defiance, rebellion, empowerment
- Fear: anxiety, worry, tension, uncertainty
- Surprise: curiosity, wonder, intrigue
- Disgust: rejection, dissatisfaction, sarcasm
- Love: romance, affection, warmth, passion
- Calm: peacefulness, relaxation, serenity, mindfulness
- Energy: motivation, workout, drive, adrenaline

Emotional Depth:
I also detect the intensity ‚Äî mild, moderate, or intense.
I sense the vibe ‚Äî dreamy, dark, bright, urban, vintage, ambient.
I factor in context ‚Äî time of day, seasonal hints, weather cues if shared (rainy day, sunny morning, cozy night).

How I Build the Perfect Query:
1. Extract the main emotion(s) from the user‚Äôs words.
2. Identify any energy cues ‚Äî upbeat, mellow, heavy, soft.
3. Add any contextual hints ‚Äî genre, weather, location, or activity (study, workout, sleep).
4. Merge these into a precise query string.
5. Always output in pure JSON: {"query":"emotional keywords here","type":"track"} ‚Äî no extra words.

QueryKnowledge:
I know how to:
- Translate emotions into suitable genre or vibe keywords:
  - Joy ‚Üí upbeat pop, indie pop, dance pop
  - Heartbreak ‚Üí acoustic, soft piano, lo-fi sad
  - Empowerment ‚Üí rap, rock anthems, trap beats
  - Calm ‚Üí ambient, chillhop, soft instrumental
- Detect energy levels:
  - Mild ‚Üí soft, acoustic, chill
  - Moderate ‚Üí mellow beats, smooth flow
  - Intense ‚Üí high BPM, energetic pop, rock, hip-hop
- Add vibe styling:
  - Dreamy ‚Üí ambient, ethereal, lush reverb
  - Dark ‚Üí moody, haunting vocals, minor keys
  - Bright ‚Üí lively, colorful instrumentation
- Factor in context:
  - Study ‚Üí focus, instrumental, lo-fi beats
  - Workout ‚Üí high-energy, hype tracks
  - Sleep ‚Üí calm, ambient, soft piano
- Mix known artists:
  - If the user says an artist‚Äôs name, I blend their style with the emotion:
    - "Frank Ocean heartbreak" ‚Üí mellow, soulful, chill R&B heartbreak

Examples (guidelines, not exact words):

- If the user says they feel lonely on a rainy day, combine synonyms for loneliness (solitude, isolation) + rainy weather + acoustic or lo-fi vibe.
  ‚Üí Example output: {"query":"[loneliness synonym] [rainy/gloomy] [time context if any] [acoustic/lo-fi/mellow vibe]","type":"track"}

- If the user wants nostalgia, blend synonyms (nostalgic, wistful, retro) + dreamy or vintage genre.
  ‚Üí Example output: {"query":"[nostalgia synonym] [dreamy/retro/vintage] [soft/indie]","type":"track"}

- If the user wants upbeat workout music, combine synonyms for motivation (hype, energetic) + activity (gym/run) + genre (pop/rock/rap).
  ‚Üí Example output: {"query":"[motivational synonym] [workout/gym/run] [high energy pop/rock/rap]","type":"track"}

- If the user mentions an artist + mood, merge the artist‚Äôs name with the emotional vibe.
  ‚Üí Example output: {"query":"[artist name] [mood keyword] [vibe keywords]","type":"track"}

I always:
- Use fresh synonyms.
- Adjust vibe words every time.
- Adapt context words (time, weather, activity).
- Never repeat the exact same phrase.

Strict Rules:
- If the user says ‚Äúhi‚Äù, ‚Äúhey‚Äù, ‚Äúhello‚Äù, ‚Äúgood morning‚Äù, ‚Äúgood evening‚Äù, or gives no mood, no emotion, or no music request:
  - Reply warmly, within 50 words.
  - DO NOT output any JSON at all.
- If the user gives an emotion, mood, or asks for music:
  - Reply warmly (under 50 words if possible).
  - Then include the final query as pure JSON at the end, on a new line.
  - The JSON must not be empty ‚Äî always use real keywords.
  - Do not wrap the JSON in markdown or quotes.
- If the user gives an artist name, blend the artist‚Äôs style with the mood and find a suitable track.
- Never mention ‚Äúsong‚Äù or ‚Äúplaylist‚Äù in the reply text ‚Äî only in the JSON if needed.
- Prefer short replies unless the user wants a story or something detailed.
- No extra text after the JSON.

Fallback:
I warmly greet them and kindly ask how they‚Äôre feeling.
I do *not* produce any JSON in this case.
If they do share a mood, I follow the rules above.

The user just said: "${userMessage}".
`;

const llamaRes = await askLlama(prompt);
console.log('üß† LLaMA:', llamaRes);

let parsed;

// Try parsing LLaMA output
try {
  parsed = JSON.parse(llamaRes);
} catch {
  const match = llamaRes.match(/\{[\s\S]*?\}/);
  if (match) {
    try {
      parsed = JSON.parse(match[0]);
    } catch {
      return res.json({ reply: llamaRes, url: null });
    }
  } else {
    // No JSON found ‚Üí casual message ‚Üí send warm reply only
    return res.json({ reply: llamaRes, url: null });
  }
}

// No valid query ‚Üí avoid lookup
if (!parsed.query?.trim()) {
  return res.json({ reply: llamaRes, url: null });
}

const { query, type } = parsed;

let resultUrl = '';
const queryWords = query.toLowerCase().split(/\s+/);

let matchedMood = null;
let matchedArtist = null;
let matchedSong = null;

// Find mood
matchedMood = moodsData.moods.find(m =>
  queryWords.includes(m.mood.toLowerCase()) ||
  (m.synonyms && m.synonyms.some(syn => queryWords.includes(syn.toLowerCase())))
);

// Find artist
moodsData.moods.forEach(mood => {
  mood.songs.forEach(song => {
    const artistNameWords = song.artist.toLowerCase().split(/\s+/);
    const artistMatch = artistNameWords.some(word => queryWords.includes(word));
    if (artistMatch) {
      matchedArtist = song.artist;
    }
  });
});

// If both mood and artist, find song that matches both
if (matchedMood && matchedArtist) {
  matchedSong = matchedMood.songs.find(song =>
    song.artist.toLowerCase() === matchedArtist.toLowerCase()
  );
}

// If no exact song for both, find any song by artist
if (!matchedSong && matchedArtist) {
  moodsData.moods.forEach(mood => {
    mood.songs.forEach(song => {
      if (song.artist.toLowerCase() === matchedArtist.toLowerCase()) {
        matchedSong = song;
      }
    });
  });
}

// If only mood, get random song from mood
if (!matchedSong && matchedMood) {
  matchedSong = matchedMood.songs[Math.floor(Math.random() * matchedMood.songs.length)];
}

// If still nothing, fallback to any title match
if (!matchedSong) {
  moodsData.moods.forEach(mood => {
    mood.songs.forEach(song => {
      const songTitleWords = song.title.toLowerCase().split(/\s+/);
      if (songTitleWords.some(word => queryWords.includes(word))) {
        matchedSong = song;
      }
    });
  });
}

if (matchedSong) {
  resultUrl = `https://open.spotify.com/search/${encodeURIComponent(matchedSong.title + ' ' + matchedSong.artist)}`;
} else {
  resultUrl = '';
}

const cleanReply = llamaRes.replace(/\{[\s\S]*?\}/, '').trim();

return res.json({
  reply: cleanReply,
  url: resultUrl
});

// üéß If not in moods.json, use Spotify API
if (type === 'track') {
  const spotifyRes = await fetch(
    `https://api.spotify.com/v1/search?q=${encodeURIComponent(query)}&type=track&limit=10`,
    { headers: { Authorization: `Bearer ${spotifyToken}` } }
  );
  const data = await spotifyRes.json();
  console.log('üéµ Spotify track data:', JSON.stringify(data, null, 2));

  const popularTracks = data.tracks?.items?.filter(track => track.popularity >= 70) || [];

  if (popularTracks.length > 0) {
    resultUrl = popularTracks[0].external_urls.spotify;
  } else {
    console.log('‚ö†Ô∏è No popular tracks found, trying playlist...');
    const fallbackRes = await fetch(
      `https://api.spotify.com/v1/search?q=${encodeURIComponent(query)}&type=playlist&limit=1`,
      { headers: { Authorization: `Bearer ${spotifyToken}` } }
    );
    const fallbackData = await fallbackRes.json();
    console.log('üéµ Spotify playlist data:', JSON.stringify(fallbackData, null, 2));
    if (fallbackData.playlists?.items?.length > 0) {
      resultUrl = fallbackData.playlists.items[0].external_urls.spotify;
    } else {
      console.log('‚ö†Ô∏è No playlists found, trying artist...');
      const artistRes = await fetch(
        `https://api.spotify.com/v1/search?q=${encodeURIComponent(query)}&type=artist&limit=1`,
        { headers: { Authorization: `Bearer ${spotifyToken}` } }
      );
      const artistData = await artistRes.json();
      console.log('üéµ Spotify artist data:', JSON.stringify(artistData, null, 2));
      if (artistData.artists?.items?.length > 0) {
        resultUrl = artistData.artists.items[0].external_urls.spotify;
      } else {
        console.log('‚ùå Nothing found for this query!');
      }
    }
  }
}

return res.json({
  reply: llamaRes,
  url: resultUrl || null
});
} catch (err) {
  console.error('‚ùå Chat endpoint failed:', err);
  res.status(500).json({ reply: 'Oops! Something went wrong.' });
}
});

app.listen(3000, () => {
  console.log('‚úÖ Server running on http://localhost:3000');
});